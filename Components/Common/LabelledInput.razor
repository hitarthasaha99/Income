@using System.Globalization
@typeparam TValue
@inherits InputBase<TValue>

<div class="labeled-input">
    <input @bind="CurrentValueAsString"
           @attributes="AdditionalAttributes"
           class="form-control @GetCssClass()" />

    @if (!string.IsNullOrEmpty(Label))
    {
        <label>@Label</label>
    }

    @if (IsError && !string.IsNullOrEmpty(ErrorMessage))
    {
        <div class="validation-message" style="color:@GetColor(ErrorSeverity)">
            @ErrorMessage
        </div>
    }
</div>

@code {
    [Parameter] public string Label { get; set; }
    [Parameter] public bool IsError { get; set; } = false;
    [Parameter] public ValidationSeverity ErrorSeverity { get; set; } = ValidationSeverity.Hard;
    [Parameter] public string ErrorMessage { get; set; }

    private string GetCssClass()
    {
        if (!IsError) return "";
        return ErrorSeverity == ValidationSeverity.Hard ? "border-red-500" : "border-green-500";
    }

    private string GetColor(ValidationSeverity severity) =>
        severity == ValidationSeverity.Hard ? "red" : "green";

    // InputBase<T> requires this for two-way binding
    protected override bool TryParseValueFromString(string value, out TValue result, out string validationErrorMessage)
    {
        if (BindConverter.TryConvertTo<TValue>(value, CultureInfo.CurrentCulture, out var parsedValue))
        {
            result = parsedValue;
            validationErrorMessage = null;
            return true;
        }

        result = default;
        validationErrorMessage = $"Invalid value for type {typeof(TValue).Name}";
        return false;
    }

    public enum ValidationSeverity
    {
        Hard,
        Soft,
    }
}
